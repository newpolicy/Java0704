


-1교시-

클래스의 구성 요소
1.생성자(Constructor) - 인스턴스를 만들기 위한 메소드
2.변수(variable - field): 저장하기 위한 용도
3.메소드(method): 작업을 수행하기 위한 용도

클래스 종류
1.일반 클래스
2.final 클래스: 상속할 수 없는 클래스
3.abstract 클래스: 인스턴스를 생성할 수 없는 클래스// 반드시 상속을 해서 사용해야 합니다.
4.인터페이스(원래 클래스는 아니지만 등급이 같음): 인스턴스를 생성할 수 없고 다른 인터페이스에 상속하거나 클래스에 구현해서 사용해야 합니다.

--document에 나와있는 클래스의 구성요소
1.Field Summary: static(클래스가 소유하고 공유하는 것) final(값을 변경할 수 없음) 변수들에 대한 설명 // 메소드들에서 사용할 수 있는 옵션
               -클래스이름. 으로 호출
2.Constructor Summary == 생성자
              -생성자가 없는 경우: 인터페이스, 추상클래스, 모든 멤버가 static인 클래스(Math, System....)
3.Method Summary ==메소드
              -static이 붙은 것과 그렇지 않은 것을 먼저 구분
              -abstract: 하위 클래스에서 재정의 해서 사용
              -final: 하위 클래스에서 재정의하면 안되는 메소드
              -가장 하단에 상속받은 메소드를 보여줍니다.
              -하단에 별도로 보여주는 메소드는 상속받은 메소드를 그대로 사용하는 것이고, 하단에 별도로 있지 않은 상속받은 메소드는 오버라이딩 해서 기능을 확장한것

java.lang.System 이라는 클래스에는 exit(int code)라는 프로그램을 종료하는 메소드가있다.
활용 해보자.

import java.util.Scanner;
public class Main_1t {
	public static void main(String[] args) {
		System.out.println("시스템을 종료하고 싶으면 '종료좀 해주세요 제발'을 입력하시오");
		for (int a= 0; a<4; a++ )
		{
		Scanner sc = new Scanner(System.in);
		String j = sc.nextLine();
		if(j.equals("종료좀 해주세요 제발"))
		{
			System.exit(0);
			System.out.println("종료");
			}
		else {
			System.out.println("다시 공손하게 \n");
		}
		}
	}
}
www.jungol.co.kr == 자바 문제 은행. 난이도 하
www.algospot.com == 자바 문제 은행 난이도 상
www.java2s.com/Code/JavaAPI/CatalogJavaAPI.htm == 자바 샘플 코드 사이트
www.java2s.com/Tutorial/Java/CatalogJava.htm == 자바 샘플 코드 사이트

--2교시--

예외처리(Exception Handling)
프로그램에서 발생하는 문제
1.물리적 오류(error): 프로그램을 작성할 때 문법적인 오류를 발생시켜서 프로그램이 시작되지 않는 것으로 Eclipse에서는 줄넘버 옆에 빨간색 사각형이 보입니다.
2.논리적 오류: 문법적인 오류는 없어서 프로그램이 실행되는데 로직을 잘못 만들어서 결과가 이상하게 출력되는 경우로 디버깅을 통해서 찾아내야 한다.
          -디버깅: 논리적 오류나 예외 발생지점을 찾기 위해서 메모리의 값을 확인하는 작업입니다.
3.예외(Exception): 문법적인 오류는 아니어서 프로그램이  실행은 되지만 실행 도중 예기치 않은 상황 발생으로 프로그램이 중단되는 것
                                 예외처리를 통해서 예외가 발생하면 예외를 기록하던가 예외가 발생해도 계속 프로그램을 동작하도록 만들어 주어야 합니다.
                                 디버깅을 통해서 찾아내기도 하고 콘솔 창을 확인해서 찾아내기도 합니다.
4.단언(assert): 프로그램이 특정 조건을 만족하지 않는 경우 예외를 발생시켜 강제로 중단시키는 것 

이클립스에서 디버깅하기 // 라인번호 옆의 gutter에 마우스 오른쪽을 클릭하면 중단점을 추가하거나 삭제할 수 있습니다.  ->run -> Debug 실행

---3교시---

예외처리 목적 // -예외가 발생하더라도 프로그램을 계속 실행 할 수 있도록 하기 위해
             -예외 내용을 기록해서 다음에 이러한 예외가 발생하지 않도록 프로그램을 수정하기 위해
goto package exception;

예외의 종류
1.Runtime Exception: 예외 발생 여부를 컴파일러가 체크하지 않는 예외로 개발자가 직접 예외를 처리해야 하는 것.
2.일반 Exception: 컴파일러가 예외 발생 여부를 체크하는 것으로 개발자가 예외 처리 코드를 반드시 작성해야 하는 예외.

3.NullPointerException: null이 무언인가를 호출해서 발생하는 예외입니다. 호출하는 인스턴스를 확인해 봐야 합니다. 초보자에게 가장 많이 보이는 예외입니다.


----4교시----

예외처리 방법
1. 직접 try - catch - finally 블록을 만드는 방법
2. 예외를 발생한 곳으로 던지는 방법

try블록 - catch블록 finally블록

try{
   예외 발생 가능성이 있는 코드;
}
catch (예외클래스 이름 변수명) {
   예외 클래스에 해당하는 예외가 발생했을 때 수행할 내용;
}
finally{
   예외 발생여부에 상관없이 수행할 내용;
}
==catch는 클래스 이름이 다르면 여러 개 사용 가능
==finally가 있다면 catch는 생략가능 합니다.
==finally는 catch가 있다면 생략이 가능합니다.
==try가 나오면 1개 이상의 catch나  1개의 finally가 나와야 합니다.
==여러 개의 예외를 한번에 처리하고자 할 때는 Exception 클래스를 이용하면 됩니다.
//상위 클래스 타입으로 만들어진 변수에는 하위 클래스 타입의 인스턴스 주소를 대입할 수 있습니다.


-----5교시-----

finally // 예외 발생 여부에 상관없이 수행되닌 구문을 작성하는 블록이다. 여기에는 일반적으로 외부자원과의 연결을 해제하는 코드를 작성한다.
4.예외의 인위적 발생
==예외상황이 아닌데 강제로 예외를 발생
throw new 예외클래스 이름(String message);

5.예외처리를 호출한 곳으로 넘겨주기
==예외가 발생한 메소드에서 예외를 처리하는 것이 아니라 메소드를 호출한 곳에서 처리하도록 하는 것.
==메소드 안에서 예외를 처리하게 되면 예외를 처리하는 코드와 비지니스 로직(사용자의 요구를 처리하기 위한 코드)을 한곳에 두면 코드를 보기가 어려워지기 때문에
비지니스로직과 예외 처리코드를 분리하기 위해서 예외 처리를 호출한 곳으로 넘겨서 처리하는경우가 많습니다.
==메소드 매개변수 뒤에 throws 예외이름클래스이름을 적어주면 이 메소드의 예외는 호출한 곳에서 처리해야 합니다.

==어떤 메소드를 사용하고자 할때 throws절이 있으면  반드시 예외 처리를 해 주어야 합니다.

예외처리 권장사항
==반복문 안에서 사용하는 것은 바람직하지 않습니다. 
 
java.lang.Object
==자바 최상위 클래스 - 모든 자바의 클래스는 이 클래스를 상속합니다.
==Object 클래스는 인스턴스를 만들기 위해서 만든 클래스가 아니고 다른 모든 클래스가 공통으로 가져야 하는 메소드들을 만들어 놓기 위해서 만든 클래스 입니다.

------6교시------
주요 메소드
1. String toString(): 인스턴스의 문자열을 리턴하는 메소드 // 기본적으로는 클래스이름과 해시코드(인스턴스를 구분하기 위한 문자열)를 문자열로 리턴;
                      // 하위 클래스에서 재정의해서 사용하는 경우가 많습니다. //toString을 만드는 이유 == 디버깅을 빨리해보려고 == 검사를 빠르게 하기위해
                                         
2.bloolean equals(Object other): 인스턴스의 내용이 같은지 비교하는 메소드  "==":저장된 값이 같은지 비교하는 연산자 
                                                             //주소를 저장하는 인스턴스들은 ==로는 내용을 비교할수 없어 equals를 재정의해 사용
                                                                                                                      
3.Object clone(): 인스턴스 내용을 복제해서 새로운 인스턴스를 리턴하는 메소드 // 재정의해서 사용해야 합니다.

4.notify(), notifyAll(), wait(): 멀티 스레드 환경에서 생산자와 소비자와의 문제를 해결하기 위한 메소드.

//toSring 메소드만은 직접 호출하지 않고 출력을 하는 메소드에게 인스턴스 이름을 기재한 경우 자동으로 호출됩니다.
























































              